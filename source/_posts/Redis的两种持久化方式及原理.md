---
title: Redis的两种持久化方式及原理
date: 2017-03-26 19:49:15
tags: Redis
categories:
description:
---




Redis的所有数据都是保存在内存中，然后**不定期的通过异步方式保存到磁盘上**(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。数据持久化通俗讲就是把数据保存到磁盘上，保证不会因为断电等因素丢失数据。
redis 需要经常将内存中的数据同步到磁盘来保证持久化。redis支持两种持久化方式，一种是 Snapshotting(快照)也是默认方式，另一种是Append-only file(aof)的方式。


<!--more-->
## 一、Snapshotting(快照)

默认redis是会以快照的形式将数据持久化到磁盘的（一个二进制文件`dump.rdb`，这个文件名字可以指定），在配置文件中的格式是：
`save N M`
表示在N秒之内，redis至少发生M次修改则redis抓快照到磁盘。当然我们也可以手动执行save或者bgsave（异步）做快照。
可以通过配置设置自动做快照持久化的方式。我们可以配置redis在n秒内如果超过m个key被修改就自动做快照，下面是默认的快照保存配置：
```xml
save 900 1  	#900秒内如果超过1个key被修改，则发起快照保存
save 300 10 	#300秒内容如超过10个key被修改，则发起快照保存
save 60 10000
```

###工作原理简单介绍
当redis需要做持久化时，redis会fork一个子进程；子进程将数据写到磁盘上一个临时RDB文件中；当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处就是可以copy-on-write，主进程不进行任何I/O操作，确保了redis的性能。


### 详细的快照保存过程

1. redis调用fork，现在有了子进程和父进程。
2. 父进程继续处理client请求，子进程负责将内存内容写入到临时文件。由于os的写时复制机制(copy on write)父子进程会共享相同的物理页面，当父进程处理写请求时os会为父进程要修改的页面创建副本，而不是写共享的页面。所以子进程的地址空间内的数据是fork时刻整个数据库的一个快照。
3. 当子进程将快照写入临时文件完毕后，用临时文件替换原来的快照文件，然后子进程退出。

client也可以使用`save`或者`bgsave`命令通知redis做一次快照持久化。save操作是在主线程中保存快照的，由于redis是用一个主线程来处理所有 client的请求，**这种方式会阻塞所有client请求。所以不推荐使用**。另一点需要注意的是，**每次快照持久化都是将内存数据完整写入到磁盘一次，并不是增量的只同步脏数据**。如果数据量大的话，而且写操作比较多，必然会引起大量的磁盘io操作，可能会严重影响性能。

另外由于快照方式是在一定间隔时间做一次的，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用aof持久化方式。



## 二、Append-only File(AOF)


**Snapshotting持久化方法在redis异常死掉时， 最近的数据会丢失（丢失数据的多少视你save策略的配置），所以这是它最大的缺点**，当业务量很大时，丢失的数据是很多的。**Append-only方法可以做到全部数据不丢失，但redis的性能就要差些**。AOF就可以做到全程持久化，只需要在配置文件中开启（默认是no），`appendonly yes`开启AOF之后，redis每执行一个修改数据的命令，都会把它添加到aof文件中，当redis重启时，将会读取AOF文件进行“重放”以恢复到 redis关闭前的最后时刻。

aof比快照方式有更好的持久化性，是由于在使用aof持久化方式时，redis会将每一个收到的写命令都通过write函数追加到文件中(默认是appendonly.aof)。当redis重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。当然由于os会在内核中缓存write做的修改，所以可能不是立即写到磁盘上。这样aof方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉redis我们想要通过fsync函数强制os写入到磁盘的时机。有三种方式如下 ：
```xml
appendfsync always   # 每提交一个修改命令都调用fsync刷新到AOF文件，非常非常慢，但也非常安全
appendfsync everysec # 每秒钟都调用fsync刷新到AOF文件，很快，但可能会丢失一秒以内的数据
appendfsync no       # 依靠OS进行刷新，redis不主动刷新AOF，这样最快，但安全性就差。
```
**默认并推荐每秒刷新，这样在速度和安全上都做到了兼顾。**

可能由于系统原因导致了AOF损坏，redis无法再加载这个AOF，可以按照下面步骤来修复：首先做一个AOF文件的备份，复制到其他地方；修复原始AOF文件，执行：`$ redis-check-aof –fix` ，可以通过`diff –u`命令来查看修复前后文件不一致的地方；重启redis服务。

LOG Rewrite的工作原理：同样用到了copy-on-write：首先redis会fork一个子进程；子进程将最新的AOF写入一个临时文件；父进程增量的把内存中的最新执行的修改写入（这时仍写入旧的AOF，rewrite如果失败也是安全的）；当子进程完成rewrite临时文件后，父进程会收到 一个信号，并把之前内存中增量的修改写入临时文件末尾；这时redis将旧AOF文件重命名，临时文件重命名，开始向新的AOF中写入。

最后，为以防万一（机器坏掉或磁盘坏掉），记得定期把使用 Snapshotting 或 Append-only 生成的*rdb *.aof文件备份到远程机器上。**可以用crontab每半小时SCP一次。**

因为采用追加方式，aof也同时带来了另一个问题：**持久化文件会变的越来越大。**例如我们调用`incr test`命令100次，文件中必须保存全部的100条命令，其实**有99条都是多余的**。因为要恢复数据库的状态其实文件中保存一条set test 100就够了。为此，redis提供了文件重写(rewrite)机制，即当AOF文件大小超过阈值时，redis会启动内容压缩，只保留可以恢复数据的最小指令集。**为了压缩aof的持久化文件，redis提供了bgrewriteaof命令**。收到此命令redis将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。具体过程如下：
1. redis调用fork ，现在有父子两个进程
2. 子进程根据内存中的数据库快照，往临时文件中写入重建数据库状态的命令
3. 父进程继续处理client请求，除了把写命令写入到原来的aof文件中。同时把收到的写命令缓存起来。这样就能保证如果子进程重写失败的话并不会出问题。
4. 当子进程把快照内容写入已命令方式写到临时文件中后，子进程发信号通知父进程。然后父进程把缓存的写命令也写入到临时文件。
5. 现在父进程可以使用临时文件替换老的aof文件，并重命名，后面收到的写命令也开始往新的aof文件中追加。

需要注意到是重写aof文件的操作，并没有读取旧的aof文件，而是**将整个内存中的数据库内容用命令的方式重写了一个新的aof文件**，这点和快照有点类似。

如果运气比较差，AOF文件出现了被写坏的情况，也不必过分担忧，redis并不会贸然加载这个有问题的AOF文件，而是报错退出。这时可以通过以下步骤来修复出错的文件：
1. 备份被写坏的AOF文件
2. 运行redis-check-aof –fix进行修复
3. 用diff -u来看下两个文件的差异，确认问题点
4. 重启redis，加载修复后的AOF文件

<!--more-->