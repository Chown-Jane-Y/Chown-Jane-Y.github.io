---
title: 浅析Python的垃圾回收机制
date: 2017-03-23 10:08:02
tags: Python
categories: Python学习之路
description:
---


现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是C/C++里用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。

对于一个字符串、列表、类甚至数值都是对象，且定位简单易用的语言，自然不会让用户去处理如何分配回收内存的问题。python里也同java一样采用了垃圾收集机制，不过不一样的是：

**python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略。**

<!--more-->

## 一、引用计数机制

>为每个内存对象维护一个引用计数。当有新的引用指向某对象时就将该对象的引用计数加一，当指向该对象的引用被销毁时将该计数减一，当计数归零时，就回收该对象所占用的内存资源。

Python里每一个东西都是对象，它们的核心就是一个结构体：`PyObject`
```cpp
 typedef struct_object {
	 int ob_refcnt;
	 struct_typeobject *ob_type;
} PyObject;
```
`PyObject`是每个对象必有的内容，其中`ob_refcnt`就是做为引用计数。当一个对象有新的引用时，它的`ob_refcnt`就会增加，当引用它的对象被删除，它的`ob_refcnt`就会减少。
```cpp
#define Py_INCREF(op)   ((op)->ob_refcnt++) //增加计数
#define Py_DECREF(op) \ //减少计数
    if (--(op)->ob_refcnt != 0) \
        ; \
    else \
        __Py_Dealloc((PyObject *)(op))
```
当引用计数为0时，该对象生命就结束了。

用图来解释一下：
![ob_refcnt](http://i4.buimg.com/588729/dbd8f4928350912e.jpg)










节点旁的数字代表引用计数。所有对象保存着自己被别人引用的次数，减少一次，则自身减少1，同时自己引用的对象的引用计数也减少1。图中B到D的引用失效，D引用的E的对象计数也减1。D、E引用计数都变为0，被回收。




**引用计数机制的优点**：

- 简单易懂
- 实时性：一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。

**引用计数机制的缺点**：
- 维护引用计数消耗资源
- 循环引用 

在如今的硬件水平下，第一个缺点可以接受，但是**循环引用**会导致内存泄漏，会产生严重的后果。什么是循环引用呢？看下面的例子：
```python
list1 = []     			# list1的引用计数为1
list2 = []				# list2的引用计数为1
list1.append(list2)		# list2的引用计数加1，变为2
list2.append(list1)		# list1的引用计数加1，变为2
del list1				# list1的引用计数减1，变为1
del list2				# list2的引用计数减2，变为1
```
list1和list2相互引用后，引用计数都加1。用`del`删除了用于引用的变量名后，按理说现在不存在其他对象对它们的引用，list1和list2指向的内存应该被回收。但由于list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，就会导致内存泄漏。

为了解决这个问题，Python引入了其他回收机制作为辅助，就是标记-清除和分代收集机制。

## 二、标记-清除

>分两个步骤，一是标记，即从众多的内存对象中区分出不会再被使用的垃圾对象；二是清除，即把标记的垃圾对象清除掉。标记的时候需要确定内存对象的集合Root set，集合里的对象都是可以访问的。如果Root set中的对象引用了其他的对象，那么被引用的对象也不能被标记为垃圾对象。然后从Root set出发，递归遍历Root set能访问到的所有对象，进行标记为不是垃圾对象。遍历结束后，没有被标记的就是垃圾对象。


标记-清除是一种基于追踪（Tracing）回收技术实现的垃圾回收算法，对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的对象标记为有用的对象，不可达的对象就是要被清除的对象。所谓**根象就是一些全局引用对象和函数栈中的引用**，这些引用所引用的对象是不可被删除的。

![Mark&Sweep](http://i4.buimg.com/588729/138ef333d4908d0d.jpg)




















图中A是根节点，无法通过有向边到达D、E节点，把可到达的节点标为有用节点，回收不可到达的无用节点。



标记-清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。


## 三、分代回收

>根据一个统计学上的结论，如果一个内存对象在某次Mark过程中发现不是垃圾，那么它短期内成为垃圾的可能性就很小。分代收集将那些在多次垃圾收集过程中都没有被标记为垃圾对象的内存对象集中到另外一个区域——年老的区域，即这个区域中的内存对象年龄比较大。因为年老区域内内存对象短期内变成垃圾的概率很低，所以这些区域的垃圾收集频率可以降低，相对的，对年轻区域内的对象进行高频率的垃圾收集。这样可以提高垃圾收集的整体性能。


基本假说：大部分新产生的对象会在较短时间内成了垃圾，而经过一定时间依然存活的对象一般寿命较长。

依据此假说，那么只要扫描新生代的对象就可以实现大部分垃圾的回收。

Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，**Python将内存分为了3代，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代）**，他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。

比方说年轻代清理10次后，进行一次中年代的垃圾清理；中年代清理10次后，再进行一次老年代的垃圾清理。以这个频率来进行分代回收，这个频率可以自己设置。

新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去。依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。

<!--more-->

